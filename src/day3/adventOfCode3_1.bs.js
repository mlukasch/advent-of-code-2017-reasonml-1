// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array    = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function calculateStepsToMemorySlot(n) {
  var arraySize = (Math.ceil(Math.sqrt(n)) | 0) + 1 | 0;
  var array = $$Array.make_matrix(arraySize, arraySize, -1);
  var half = arraySize / 2 | 0;
  var out = function (i) {
    if (i < 0) {
      return /* true */1;
    } else {
      return +(i >= n);
    }
  };
  var shouldTurn = function (param) {
    var y = param[1];
    var x = param[0];
    if (out(x) || out(y)) {
      return /* true */1;
    } else {
      return +(Caml_array.caml_array_get(Caml_array.caml_array_get(array, x), y) === -1);
    }
  };
  var step = function (x, y, param) {
    return /* tuple */[
            x + param[0] | 0,
            y + param[1] | 0
          ];
  };
  var turn = function (param) {
    return /* tuple */[
            -param[1] | 0,
            param[0]
          ];
  };
  var memoryPos = [/* tuple */[
      0,
      0
    ]];
  var iter = function (_param, _d, _i) {
    while(true) {
      var param = _param;
      var i = _i;
      var d = _d;
      var y = param[1];
      var x = param[0];
      Caml_array.caml_array_set(Caml_array.caml_array_get(array, x), y, i);
      if (i === n) {
        memoryPos[0] = /* tuple */[
          x,
          y
        ];
        return /* () */0;
      } else if (i < (Caml_int32.imul(arraySize, arraySize) - 1 | 0)) {
        var d$prime = shouldTurn(step(x, y, turn(d))) ? turn(d) : d;
        _i = i + 1 | 0;
        _d = d$prime;
        _param = step(x, y, d$prime);
        continue ;
        
      } else {
        return 0;
      }
    };
  };
  var start = /* tuple */[
    half,
    half
  ];
  iter(start, /* tuple */[
        1,
        0
      ], 1);
  var match = memoryPos[0];
  if (half) {
    var dx = Pervasives.abs(match[0] - half | 0);
    var dy = Pervasives.abs(match[1] - half | 0);
    return dx + dy | 0;
  } else {
    return 1;
  }
}

console.log(calculateStepsToMemorySlot(1));

console.log(calculateStepsToMemorySlot(12));

console.log(calculateStepsToMemorySlot(23));

console.log(calculateStepsToMemorySlot(1024));

console.log(calculateStepsToMemorySlot(277678));

var myInput = 277678;

exports.myInput                    = myInput;
exports.calculateStepsToMemorySlot = calculateStepsToMemorySlot;
/*  Not a pure module */
