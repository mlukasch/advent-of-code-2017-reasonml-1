// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function calculateStepsToMemorySlot(n) {
  var arraySize = (Math.ceil(Math.sqrt(n)) | 0) + 1 | 0;
  var array = $$Array.make_matrix(arraySize, arraySize, 0);
  var half = arraySize / 2 | 0;
  var out = function (i) {
    if (i < 0) {
      return /* true */1;
    } else {
      return +(i >= n);
    }
  };
  var shouldTurn = function (param) {
    var y = param[1];
    var x = param[0];
    if (out(x) || out(y)) {
      return /* true */1;
    } else {
      return +(Caml_array.caml_array_get(Caml_array.caml_array_get(array, x), y) === 0);
    }
  };
  var step = function (x, y, param) {
    return /* tuple */[
            x + param[0] | 0,
            y + param[1] | 0
          ];
  };
  var turn = function (param) {
    return /* tuple */[
            -param[1] | 0,
            param[0]
          ];
  };
  var adjacentSquaresValue = function (x, y) {
    return List.fold_left((function (a, param) {
                  var value;
                  try {
                    value = Caml_array.caml_array_get(Caml_array.caml_array_get(array, x + param[0] | 0), y + param[1] | 0);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
                      if (exn[1] === "index out of bounds") {
                        value = 0;
                      } else {
                        throw exn;
                      }
                    } else {
                      throw exn;
                    }
                  }
                  return a + value | 0;
                }), 0, /* :: */[
                /* tuple */[
                  -1,
                  -1
                ],
                /* :: */[
                  /* tuple */[
                    -1,
                    0
                  ],
                  /* :: */[
                    /* tuple */[
                      -1,
                      1
                    ],
                    /* :: */[
                      /* tuple */[
                        0,
                        -1
                      ],
                      /* :: */[
                        /* tuple */[
                          0,
                          1
                        ],
                        /* :: */[
                          /* tuple */[
                            1,
                            -1
                          ],
                          /* :: */[
                            /* tuple */[
                              1,
                              0
                            ],
                            /* :: */[
                              /* tuple */[
                                1,
                                1
                              ],
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]);
  };
  var start = /* tuple */[
    half,
    half
  ];
  var _param = start;
  var _d = /* tuple */[
    1,
    0
  ];
  var _i = 1;
  while(true) {
    var param = _param;
    var i = _i;
    var d = _d;
    var y = param[1];
    var x = param[0];
    var match = +(i === 1);
    var value = match !== 0 ? 1 : adjacentSquaresValue(x, y);
    Caml_array.caml_array_set(Caml_array.caml_array_get(array, x), y, value);
    if (value > n) {
      console.log(value);
      return /* () */0;
    } else if (i < (Caml_int32.imul(arraySize, arraySize) - 1 | 0)) {
      var d$prime = shouldTurn(step(x, y, turn(d))) ? turn(d) : d;
      _i = i + 1 | 0;
      _d = d$prime;
      _param = step(x, y, d$prime);
      continue ;
      
    } else {
      return 0;
    }
  };
}

calculateStepsToMemorySlot(277678);

var myInput = 277678;

exports.myInput                    = myInput;
exports.calculateStepsToMemorySlot = calculateStepsToMemorySlot;
/*  Not a pure module */
